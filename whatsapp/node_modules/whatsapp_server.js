const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const axios = require('axios');
const winston = require('winston');
const qrcode = require('qrcode');
const multer = require('multer');
const mime = require('mime-types');
const uuid = require('uuid');
const path = require('path');
const fs = require('fs');
const { Server } = require('socket.io');
const http = require('http');
const helmet = require('helmet');
const { RateLimiterMemory } = require('rate-limiter-flexible');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
require('dotenv').config();

// Logger setup
const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
    ),
    transports: [
        new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/combined.log' }),
        new winston.transports.Console({
            format: winston.format.simple()
        })
    ]
});

// Express app setup
const app = express();
const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: process.env.CORS_ORIGIN || "*",
        methods: ["GET", "POST"]
    }
});

// Middleware
app.use(helmet());
app.use(cors());
app.use(bodyParser.json({ limit: '50mb' }));
app.use(bodyParser.urlencoded({ extended: true, limit: '50mb' }));

// Rate limiting
const rateLimiter = new RateLimiterMemory({
    keyPrefix: 'whatsapp_api',
    points: 100, // Number of requests
    duration: 60, // Per 60 seconds
});

// Rate limiter middleware
const rateLimitMiddleware = async (req, res, next) => {
    try {
        await rateLimiter.consume(req.ip);
        next();
    } catch (rejRes) {
        res.status(429).json({ error: 'Too Many Requests' });
    }
};

// File upload setup
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        const uploadDir = path.join(__dirname, 'uploads');
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
});

const upload = multer({ 
    storage: storage,
    limits: { fileSize: 50 * 1024 * 1024 }, // 50MB limit
    fileFilter: function (req, file, cb) {
        // Allow all file types for WhatsApp
        cb(null, true);
    }
});

// WhatsApp clients storage
const clients = new Map();
const clientQRCodes = new Map();
const clientStatus = new Map();

// Configuration
const config = {
    port: process.env.PORT || 3000,
    odooWebhookUrl: process.env.ODOO_WEBHOOK_URL || 'http://localhost:8069/whatsapp/webhook',
    jwtSecret: process.env.JWT_SECRET || 'your-jwt-secret-key',
    puppeteerOptions: {
        headless: true,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--single-process',
            '--disable-gpu'
        ]
    }
};

// JWT middleware
const verifyToken = (req, res, next) => {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
        return res.status(401).json({ error: 'No token provided' });
    }

    try {
        const decoded = jwt.verify(token, config.jwtSecret);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(401).json({ error: 'Invalid token' });
    }
};

// Create WhatsApp client
function createClient(sessionName, webhookUrl = null, apiKey = null) {
    logger.info(`Creating WhatsApp client for session: ${sessionName}`);
    
    const client = new Client({
        authStrategy: new LocalAuth({ clientId: sessionName }),
        puppeteer: config.puppeteerOptions,
        webVersionCache: {
            type: 'remote',
            remotePath: 'https://raw.githubusercontent.com/wppconnect-team/wa-version/main/html/2.2412.54.html',
        }
    });

    // Event handlers
    client.on('qr', async (qr) => {
        logger.info(`QR code generated for session: ${sessionName}`);
        
        try {
            const qrImage = await qrcode.toDataURL(qr);
            clientQRCodes.set(sessionName, { qr, qrImage });
            clientStatus.set(sessionName, 'qr');
            
            // Send to Odoo webhook
            if (webhookUrl) {
                await sendWebhook(webhookUrl, {
                    event: 'qr',
                    session: sessionName,
                    data: { qr, qr_image: qrImage }
                }, apiKey);
            }
            
            // Emit to socket
            io.emit('qr', { session: sessionName, qr, qrImage });
            
        } catch (error) {
            logger.error(`Error generating QR code for ${sessionName}:`, error);
        }
    });

    client.on('ready', async () => {
        logger.info(`WhatsApp client ready for session: ${sessionName}`);
        clientStatus.set(sessionName, 'ready');
        
        // Get client info
        const clientInfo = client.info;
        
        // Send to Odoo webhook
        if (webhookUrl) {
            await sendWebhook(webhookUrl, {
                event: 'ready',
                session: sessionName,
                data: { 
                    phone: clientInfo.wid.user,
                    name: clientInfo.pushname,
                    platform: clientInfo.platform
                }
            }, apiKey);
        }
        
        // Emit to socket
        io.emit('ready', { session: sessionName, clientInfo });
    });

    client.on('authenticated', async () => {
        logger.info(`WhatsApp client authenticated for session: ${sessionName}`);
        clientStatus.set(sessionName, 'authenticated');
        
        // Send to Odoo webhook
        if (webhookUrl) {
            await sendWebhook(webhookUrl, {
                event: 'authenticated',
                session: sessionName,
                data: {}
            }, apiKey);
        }
        
        // Emit to socket
        io.emit('authenticated', { session: sessionName });
    });

    client.on('disconnected', async (reason) => {
        logger.info(`WhatsApp client disconnected for session: ${sessionName}. Reason: ${reason}`);
        clientStatus.set(sessionName, 'disconnected');
        
        // Send to Odoo webhook
        if (webhookUrl) {
            await sendWebhook(webhookUrl, {
                event: 'disconnected',
                session: sessionName,
                data: { reason }
            }, apiKey);
        }
        
        // Emit to socket
        io.emit('disconnected', { session: sessionName, reason });
        
        // Remove from clients
        clients.delete(sessionName);
        clientQRCodes.delete(sessionName);
        clientStatus.delete(sessionName);
    });

    client.on('message', async (message) => {
        logger.info(`Message received for session: ${sessionName}`);
        
        try {
            const messageData = await formatMessage(message);
            
            // Send to Odoo webhook
            if (webhookUrl) {
                await sendWebhook(webhookUrl, {
                    event: 'message',
                    session: sessionName,
                    data: messageData
                }, apiKey);
            }
            
            // Emit to socket
            io.emit('message', { session: sessionName, message: messageData });
            
        } catch (error) {
            logger.error(`Error processing message for ${sessionName}:`, error);
        }
    });

    client.on('message_create', async (message) => {
        // Handle sent messages
        if (message.fromMe) {
            logger.info(`Message sent from session: ${sessionName}`);
            
            try {
                const messageData = await formatMessage(message);
                
                // Send to Odoo webhook
                if (webhookUrl) {
                    await sendWebhook(webhookUrl, {
                        event: 'message_sent',
                        session: sessionName,
                        data: messageData
                    }, apiKey);
                }
                
                // Emit to socket
                io.emit('message_sent', { session: sessionName, message: messageData });
                
            } catch (error) {
                logger.error(`Error processing sent message for ${sessionName}:`, error);
            }
        }
    });

    client.on('message_ack', async (message, ack) => {
        logger.info(`Message ACK for session: ${sessionName}, ACK: ${ack}`);
        
        try {
            const ackStatus = ['error', 'pending', 'server', 'device', 'read', 'played'][ack] || 'unknown';
            
            // Send to Odoo webhook
            if (webhookUrl) {
                await sendWebhook(webhookUrl, {
                    event: 'message_ack',
                    session: sessionName,
                    data: {
                        message_id: message.id._serialized,
                        ack: ackStatus
                    }
                }, apiKey);
            }
            
            // Emit to socket
            io.emit('message_ack', { session: sessionName, messageId: message.id._serialized, ack: ackStatus });
            
        } catch (error) {
            logger.error(`Error processing message ACK for ${sessionName}:`, error);
        }
    });

    client.on('group_join', async (notification) => {
        logger.info(`Group join event for session: ${sessionName}`);
        
        try {
            // Send to Odoo webhook
            if (webhookUrl) {
                await sendWebhook(webhookUrl, {
                    event: 'group_join',
                    session: sessionName,
                    data: {
                        group_id: notification.chatId,
                        participants: notification.recipientIds
                    }
                }, apiKey);
            }
            
        } catch (error) {
            logger.error(`Error processing group join for ${sessionName}:`, error);
        }
    });

    client.on('group_leave', async (notification) => {
        logger.info(`Group leave event for session: ${sessionName}`);
        
        try {
            // Send to Odoo webhook
            if (webhookUrl) {
                await sendWebhook(webhookUrl, {
                    event: 'group_leave',
                    session: sessionName,
                    data: {
                        group_id: notification.chatId,
                        participants: notification.recipientIds
                    }
                }, apiKey);
            }
            
        } catch (error) {
            logger.error(`Error processing group leave for ${sessionName}:`, error);
        }
    });

    return client;
}

// Format message for webhook
async function formatMessage(message) {
    const messageData = {
        id: message.id._serialized,
        body: message.body,
        type: message.type,
        timestamp: message.timestamp,
        from: message.from,
        to: message.to,
        fromMe: message.fromMe,
        hasMedia: message.hasMedia,
        isForwarded: message.isForwarded,
        isStatus: message.isStatus,
        isStarred: message.isStarred,
        broadcast: message.broadcast,
        isGroup: message.from.endsWith('@g.us'),
        deviceType: message.deviceType
    };

    // Add contact info
    const contact = await message.getContact();
    messageData.contact = {
        id: contact.id._serialized,
        name: contact.name,
        pushname: contact.pushname,
        shortName: contact.shortName,
        isMe: contact.isMe,
        isUser: contact.isUser,
        isGroup: contact.isGroup,
        isWAContact: contact.isWAContact,
        profilePicUrl: await contact.getProfilePicUrl().catch(() => null)
    };

    // Add quoted message info
    if (message.hasQuotedMsg) {
        const quotedMsg = await message.getQuotedMessage();
        messageData.quotedMessage = {
            id: quotedMsg.id._serialized,
            body: quotedMsg.body,
            type: quotedMsg.type,
            from: quotedMsg.from,
            timestamp: quotedMsg.timestamp
        };
    }

    // Add media info
    if (message.hasMedia) {
        const media = await message.downloadMedia();
        messageData.media = {
            mimetype: media.mimetype,
            filename: media.filename,
            size: media.data.length,
            data: media.data // Base64 encoded
        };
    }

    // Add location info
    if (message.location) {
        messageData.location = {
            latitude: message.location.latitude,
            longitude: message.location.longitude,
            description: message.location.description
        };
    }

    return messageData;
}

// Send webhook to Odoo
async function sendWebhook(webhookUrl, data, apiKey = null) {
    try {
        const headers = {
            'Content-Type': 'application/json'
        };
        
        if (apiKey) {
            headers['Authorization'] = `Bearer ${apiKey}`;
        }
        
        await axios.post(webhookUrl, data, { headers });
        logger.info(`Webhook sent successfully to ${webhookUrl}`);
        
    } catch (error) {
        logger.error(`Error sending webhook to ${webhookUrl}:`, error.message);
    }
}

// Routes

// Health check
app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Start session
app.post('/start', rateLimitMiddleware, async (req, res) => {
    try {
        const { session, webhookUrl, apiKey, phone } = req.body;
        
        if (!session) {
            return res.status(400).json({ error: 'Session name is required' });
        }
        
        if (clients.has(session)) {
            return res.status(400).json({ error: 'Session already exists' });
        }
        
        const client = createClient(session, webhookUrl, apiKey);
        clients.set(session, client);
        
        await client.initialize();
        
        res.json({ 
            success: true, 
            message: 'Session started successfully',
            session 
        });
        
    } catch (error) {
        logger.error('Error starting session:', error);
        res.status(500).json({ error: 'Failed to start session' });
    }
});

// Stop session
app.post('/stop', rateLimitMiddleware, async (req, res) => {
    try {
        const { session } = req.body;
        
        if (!session) {
            return res.status(400).json({ error: 'Session name is required' });
        }
        
        const client = clients.get(session);
        if (!client) {
            return res.status(404).json({ error: 'Session not found' });
        }
        
        await client.destroy();
        clients.delete(session);
        clientQRCodes.delete(session);
        clientStatus.delete(session);
        
        res.json({ 
            success: true, 
            message: 'Session stopped successfully' 
        });
        
    } catch (error) {
        logger.error('Error stopping session:', error);
        res.status(500).json({ error: 'Failed to stop session' });
    }
});

// Get session status
app.get('/status/:session', rateLimitMiddleware, (req, res) => {
    const { session } = req.params;
    
    const client = clients.get(session);
    if (!client) {
        return res.status(404).json({ error: 'Session not found' });
    }
    
    const status = clientStatus.get(session) || 'unknown';
    const qrData = clientQRCodes.get(session);
    
    res.json({
        session,
        status,
        qr: qrData?.qr,
        qrImage: qrData?.qrImage
    });
});

// Get QR code
app.get('/qr/:session', rateLimitMiddleware, (req, res) => {
    const { session } = req.params;
    
    const qrData = clientQRCodes.get(session);
    if (!qrData) {
        return res.status(404).json({ error: 'QR code not available' });
    }
    
    res.json({
        session,
        qr: qrData.qr,
        qrImage: qrData.qrImage
    });
});

// Send message
app.post('/send', rateLimitMiddleware, async (req, res) => {
    try {
        const { session, to, message, type = 'text', media } = req.body;
        
        if (!session || !to || !message) {
            return res.status(400).json({ error: 'Session, to, and message are required' });
        }
        
        const client = clients.get(session);
        if (!client) {
            return res.status(404).json({ error: 'Session not found' });
        }
        
        const status = clientStatus.get(session);
        if (status !== 'ready') {
            return res.status(400).json({ error: 'Session not ready' });
        }
        
        let result;
        
        if (type === 'text') {
            result = await client.sendMessage(to, message);
        } else if (type === 'media' && media) {
            const mediaMessage = MessageMedia.fromFilePath(media);
            result = await client.sendMessage(to, mediaMessage, { caption: message });
        } else {
            return res.status(400).json({ error: 'Invalid message type or missing media' });
        }
        
        res.json({
            success: true,
            messageId: result.id._serialized,
            timestamp: result.timestamp
        });
        
    } catch (error) {
        logger.error('Error sending message:', error);
        res.status(500).json({ error: 'Failed to send message' });
    }
});

// Upload and send media
app.post('/send-media', rateLimitMiddleware, upload.single('media'), async (req, res) => {
    try {
        const { session, to, caption = '' } = req.body;
        
        if (!session || !to || !req.file) {
            return res.status(400).json({ error: 'Session, to, and media file are required' });
        }
        
        const client = clients.get(session);
        if (!client) {
            return res.status(404).json({ error: 'Session not found' });
        }
        
        const status = clientStatus.get(session);
        if (status !== 'ready') {
            return res.status(400).json({ error: 'Session not ready' });
        }
        
        const media = MessageMedia.fromFilePath(req.file.path);
        const result = await client.sendMessage(to, media, { caption });
        
        // Clean up uploaded file
        fs.unlinkSync(req.file.path);
        
        res.json({
            success: true,
            messageId: result.id._serialized,
            timestamp: result.timestamp
        });
        
    } catch (error) {
        logger.error('Error sending media:', error);
        res.status(500).json({ error: 'Failed to send media' });
    }
});

// Get contacts
app.get('/contacts/:session', rateLimitMiddleware, async (req, res) => {
    try {
        const { session } = req.params;
        
        const client = clients.get(session);
        if (!client) {
            return res.status(404).json({ error: 'Session not found' });
        }
        
        const status = clientStatus.get(session);
        if (status !== 'ready') {
            return res.status(400).json({ error: 'Session not ready' });
        }
        
        const contacts = await client.getContacts();
        
        const formattedContacts = await Promise.all(
            contacts.map(async (contact) => {
                return {
                    id: contact.id._serialized,
                    name: contact.name,
                    pushname: contact.pushname,
                    shortName: contact.shortName,
                    isMe: contact.isMe,
                    isUser: contact.isUser,
                    isGroup: contact.isGroup,
                    isWAContact: contact.isWAContact,
                    profilePicUrl: await contact.getProfilePicUrl().catch(() => null)
                };
            })
        );
        
        res.json({
            success: true,
            contacts: formattedContacts
        });
        
    } catch (error) {
        logger.error('Error getting contacts:', error);
        res.status(500).json({ error: 'Failed to get contacts' });
    }
});

// Get chats
app.get('/chats/:session', rateLimitMiddleware, async (req, res) => {
    try {
        const { session } = req.params;
        
        const client = clients.get(session);
        if (!client) {
            return res.status(404).json({ error: 'Session not found' });
        }
        
        const status = clientStatus.get(session);
        if (status !== 'ready') {
            return res.status(400).json({ error: 'Session not ready' });
        }
        
        const chats = await client.getChats();
        
        const formattedChats = chats.map(chat => ({
            id: chat.id._serialized,
            name: chat.name,
            isGroup: chat.isGroup,
            isReadOnly: chat.isReadOnly,
            unreadCount: chat.unreadCount,
            timestamp: chat.timestamp,
            lastMessage: chat.lastMessage ? {
                id: chat.lastMessage.id._serialized,
                body: chat.lastMessage.body,
                type: chat.lastMessage.type,
                timestamp: chat.lastMessage.timestamp,
                from: chat.lastMessage.from,
                to: chat.lastMessage.to
            } : null
        }));
        
        res.json({
            success: true,
            chats: formattedChats
        });
        
    } catch (error) {
        logger.error('Error getting chats:', error);
        res.status(500).json({ error: 'Failed to get chats' });
    }
});

// Get chat messages
app.get('/messages/:session/:chatId', rateLimitMiddleware, async (req, res) => {
    try {
        const { session, chatId } = req.params;
        const { limit = 50 } = req.query;
        
        const client = clients.get(session);
        if (!client) {
            return res.status(404).json({ error: 'Session not found' });
        }
        
        const status = clientStatus.get(session);
        if (status !== 'ready') {
            return res.status(400).json({ error: 'Session not ready' });
        }
        
        const chat = await client.getChatById(chatId);
        const messages = await chat.fetchMessages({ limit: parseInt(limit) });
        
        const formattedMessages = await Promise.all(
            messages.map(async (message) => await formatMessage(message))
        );
        
        res.json({
            success: true,
            messages: formattedMessages
        });
        
    } catch (error) {
        logger.error('Error getting messages:', error);
        res.status(500).json({ error: 'Failed to get messages' });
    }
});

// Block contact
app.post('/block', rateLimitMiddleware, async (req, res) => {
    try {
        const { session, contactId } = req.body;
        
        if (!session || !contactId) {
            return res.status(400).json({ error: 'Session and contactId are required' });
        }
        
        const client = clients.get(session);
        if (!client) {
            return res.status(404).json({ error: 'Session not found' });
        }
        
        const status = clientStatus.get(session);
        if (status !== 'ready') {
            return res.status(400).json({ error: 'Session not ready' });
        }
        
        const contact = await client.getContactById(contactId);
        await contact.block();
        
        res.json({
            success: true,
            message: 'Contact blocked successfully'
        });
        
    } catch (error) {
        logger.error('Error blocking contact:', error);
        res.status(500).json({ error: 'Failed to block contact' });
    }
});

// Unblock contact
app.post('/unblock', rateLimitMiddleware, async (req, res) => {
    try {
        const { session, contactId } = req.body;
        
        if (!session || !contactId) {
            return res.status(400).json({ error: 'Session and contactId are required' });
        }
        
        const client = clients.get(session);
        if (!client) {
            return res.status(404).json({ error: 'Session not found' });
        }
        
        const status = clientStatus.get(session);
        if (status !== 'ready') {
            return res.status(400).json({ error: 'Session not ready' });
        }
        
        const contact = await client.getContactById(contactId);
        await contact.unblock();
        
        res.json({
            success: true,
            message: 'Contact unblocked successfully'
        });
        
    } catch (error) {
        logger.error('Error unblocking contact:', error);
        res.status(500).json({ error: 'Failed to unblock contact' });
    }
});

// Get all sessions
app.get('/sessions', rateLimitMiddleware, (req, res) => {
    const sessions = Array.from(clients.keys()).map(session => ({
        session,
        status: clientStatus.get(session) || 'unknown'
    }));
    
    res.json({
        success: true,
        sessions
    });
});

// Error handler
app.use((err, req, res, next) => {
    logger.error('Unhandled error:', err);
    res.status(500).json({ error: 'Internal server error' });
});

// Socket.io connection
io.on('connection', (socket) => {
    logger.info('Socket client connected');
    
    socket.on('disconnect', () => {
        logger.info('Socket client disconnected');
    });
    
    socket.on('join_session', (session) => {
        socket.join(session);
        logger.info(`Socket client joined session: ${session}`);
    });
    
    socket.on('leave_session', (session) => {
        socket.leave(session);
        logger.info(`Socket client left session: ${session}`);
    });
});

// Start server
const PORT = config.port;
server.listen(PORT, () => {
    logger.info(`WhatsApp server started on port ${PORT}`);
    
    // Create logs directory if it doesn't exist
    if (!fs.existsSync('logs')) {
        fs.mkdirSync('logs');
    }
});

// Handle graceful shutdown
process.on('SIGINT', async () => {
    logger.info('Shutting down server...');
    
    // Close all WhatsApp clients
    for (const [session, client] of clients) {
        try {
            await client.destroy();
            logger.info(`Client ${session} destroyed`);
        } catch (error) {
            logger.error(`Error destroying client ${session}:`, error);
        }
    }
    
    server.close(() => {
        logger.info('Server closed');
        process.exit(0);
    });
});

process.on('SIGTERM', async () => {
    logger.info('Received SIGTERM, shutting down gracefully...');
    
    // Close all WhatsApp clients
    for (const [session, client] of clients) {
        try {
            await client.destroy();
            logger.info(`Client ${session} destroyed`);
        } catch (error) {
            logger.error(`Error destroying client ${session}:`, error);
        }
    }
    
    server.close(() => {
        logger.info('Server closed');
        process.exit(0);
    });
});

module.exports = app;